'''
XOR encryptor tool.

Following parts were generated by AI:
known_signatures variable, parts of validate_input_file that handles the known signatures
as well as the output formatting of the python-array and c-array.
'''
import argparse
from pathlib import Path

def validate_input_file(file_input):
    '''
    Validates that the chosen file exists, is readable and only contain raw shellcode.
    :param file_input: Input file path
    '''
    path = Path(file_input) # path to the input file
    known_signatures = [ # used to check invalid types
        b'\x89PNG',  # PNG
        b'\xFF\xD8\xFF',  # JPEG
        b'%PDF',  # PDF
        b'\x7FELF',  # ELF
        b'MZ',  # PE (Windows executable)
        b'\x50\x4B\x03\x04',  # ZIP
        b'\x52\x61\x72\x21',  # RAR
        b'\x42\x5A\x68',  # BZ2
        b'\x1F\x8B',  # GZIP
    ]

    # Checks if input isn't a file or doesn't exist
    try:
        if not path.is_file() or not path.exists():
            raise FileNotFoundError(f"File {file_input} does not exist or is not a file.")
    except (FileNotFoundError) as error:
        print(f"[-] Error: {error}")
        exit(1)

    with open(file_input, "rb") as file: # opens the file and reads bytes
        content = file.read()

    # Checks if input file is empty
    try:
        if not content:
            raise ValueError(f"File {file_input} is empty.")
    except (ValueError) as error:
        print(f"[-] Error: {error}")
        exit(1)

    # Checks if the content of the input is of any known unacceptable formats
    try:
        for sig in known_signatures:
            if content.startswith(sig):
                sig_name = sig.decode('latin-1', errors='ignore')
                raise ValueError(f"{file_input} is a {sig_name} file, not raw shellcode.")
    except (ValueError) as error:
        print(f"[-] Error: {error}")
        exit(1)

    # If no exception is hit, input file is valid
    print(f"[+] Input file {file_input} is valid.")

def validate_key(key):
    '''
    Validates key to make sure it's a string with over 1 characters
    that can be used for the encryption.
    :param key: Key to encrypt with
    '''
    try:
        if len(key) < 1:
            raise ValueError("String key must be at least one character long")
    except (ValueError) as error:
        print(f"[-] Error: {error}")
        exit(1)

def read_input_file(file_input):
    '''
    Reads input file's bytes content and returns it so the 
    content itself can be used. 
    
    :param file_input: Input file path
    :return: Content of the input file as bytes
    '''
    with open(file_input, "rb") as f:
        print(f"[+] Reading input file: {file_input}")
        return f.read()

def xor_encrypting(data, key):
    '''
    Encrypts data using XOR encryption with the provided key.
    
    @param data: Data to be encrypted.
    @param key: Key to encrypt with.
    @return: Encrypted data.
    '''
    key = key.encode()
    output = []
    key_length = len(key)
    # Creates an object with index and corresponding byte from data
    # Uses the XOR operation on every byte comparing to the key
    for i, byte in enumerate(data):
        output.append(byte ^ key[i % key_length])
    print(f"[+] Data encrypted with key: {key.decode()}")
    return bytes(output)

def export_output(file_input, file_output, output_format="raw"):
    '''
    Exports the given input data to the specified output file in the chosen format.
    
    :param file_input: Input data to be written to the output file
    :param file_output: Output file path
    :param format: Format of the output data
    '''
    open_output = open(file_output, "wb")
    if output_format == "raw": # Writes file in raw format, as it is
        content = file_input
        open_output.write(content)
    elif output_format == "python": # Formats the output into a python array
        byte_array = ", ".join(f"0x{b:02x}" for b in file_input)
        content = f"shellcode = [{byte_array}]\n"
        open_output.write(content)
    elif output_format == "c-array": # Formats the output into an array to be copied into C code
        content = b"unsigned char xored_shellcode[] = {"
        content += b", ".join(b"0x%02x" % byte for byte in file_input)
        content += b"};"
        open_output.write(content)
    print(f"[+] Encrypted data exported to: {file_output} in format: {output_format}")
    print(f"[+] Result of encryption: {content.decode()} ")
    open_output.close()

def main():
    '''
    Main function to parse arguments and perform XOR encryption.
    '''
    parser = argparse.ArgumentParser(description="XOR encrypt tool")
    parser.add_argument("input", help="File with raw shellcode to be encrypted")
    parser.add_argument("output", help="The encrypted shellcode output file")
    parser.add_argument("key", help="String key to encrypt with")
    parser.add_argument("-f", "--format", choices=["raw", "python", "c-array"],
                     default="raw",
                     help="Output format. Raw, python or c-array allowed. Default: raw")
    args = parser.parse_args()

    validate_input_file(args.input)
    validate_key(args.key)
    ciphertext = xor_encrypting(read_input_file(args.input), args.key)
    export_output(ciphertext, args.output, args.format)

if __name__ == "__main__":
    main()
